# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

import re
from typing import List, Tuple, Dict
from dataclasses import dataclass
from mistletoe import Document, HtmlRenderer
from shared import import_tags
from shared.lumi_doc import LumiContent
from shared.utils import get_unique_id

from shared.constants import (
    PLACEHOLDER_SUFFIX,
    EQUATION_PLACEHOLDER_PREFIX,
)


@dataclass
class KatexSubstitution:
    pattern: re.Pattern
    replacement: str


# A list of unsupported KaTeX functions and their replacements.
KATEX_SUBSTITUTIONS: List[KatexSubstitution] = [
    KatexSubstitution(
        pattern=re.compile(re.escape(r"\normalfont")), replacement=r"\\text"
    ),
    KatexSubstitution(pattern=re.compile(re.escape(r"\mbox")), replacement=r"\\text"),
    KatexSubstitution(pattern=re.compile(r"\\label\{[^}]*\}"), replacement=""),
]


def parse_lumi_import(model_output_string: str) -> dict:
    """
    Parses a markdown string formatted with lumi-specific tags into a dictionary.

    Args:
        model_output_string: The input string generated by the model.

    Returns:
        A dictionary containing extracted sections:
        {'title': '...', 'authors': '...', 'abstract': '...',
         'content': '...', 'references': '...'}
        Keys will be present only if their corresponding tags are found.
    """
    parsed_data = {}

    # Define the regex pattern for each section.
    # re.DOTALL makes '.' match newlines, (.*?) makes it non-greedy.
    patterns = {
        "title": import_tags.L_TITLE_PATTERN,
        "authors": import_tags.L_AUTHORS_PATTERN,
        "abstract": import_tags.L_ABSTRACT_PATTERN,
        "content": import_tags.L_CONTENT_PATTERN,
        "references": import_tags.L_REFERENCES_PATTERN,
        "footnotes": import_tags.L_FOOTNOTES_PATTERN,
    }

    for key, pattern in patterns.items():
        match = re.search(pattern, model_output_string)
        if match:
            # Strip leading/trailing whitespace from the captured content
            parsed_data[key] = match.group(1).strip()
        # If a section is not found, the key is simply omitted from the dictionary,
        # which is often preferred over an empty string default.

    # Use re.finditer to get match objects, which allows accessing specific groups
    references_list = []
    if "references" in parsed_data:
        for match in re.finditer(
            import_tags.L_REFERENCE_ITEM_PATTERN, parsed_data["references"]
        ):
            ref_id = match.group(1)  # The N from reference-id-N
            ref_content = match.group(2).strip()  # The actual reference text
            references_list.append({"id": ref_id, "content": ref_content})

    parsed_data["references"] = references_list

    # Use re.finditer to get match objects, which allows accessing specific groups
    footnotes_list = []
    if "footnotes" in parsed_data:
        for match in re.finditer(
            import_tags.L_FOOTNOTE_CONTENT_PATTERN, parsed_data["footnotes"]
        ):
            footnote_id = match.group(1)  # The N from reference-id-N
            footnote_content = match.group(2).strip()  # The actual reference text
            footnotes_list.append({"id": footnote_id, "content": footnote_content})
    parsed_data["footnotes"] = footnotes_list

    return parsed_data


def _apply_katex_substitutions(text: str) -> str:
    """Applies KaTeX substitutions to a string."""
    for substitution in KATEX_SUBSTITUTIONS:
        text = substitution.pattern.sub(substitution.replacement, text)
    return text


def _protect_math_expressions(markdown: str) -> Tuple[str, dict]:
    """
    Replaces LaTeX math expressions with placeholders and returns a map to restore them.

    Args:
        markdown: The input markdown string.

    Returns:
        A tuple containing:
        - The markdown string with math expressions replaced by placeholders.
        - A dictionary mapping placeholders to their original math expressions.
    """
    math_placeholders = {}

    def replace_display(match):
        key = f"L_MATH_DISPLAY_{get_unique_id()}"
        math_placeholders[key] = match.group(0)
        return key

    def replace_inline(match):
        key = f"L_MATH_INLINE_{get_unique_id()}"
        math_placeholders[key] = match.group(0)
        return key

    # Process display math first to avoid capturing parts of it as inline math
    markdown = import_tags.MATH_DISPLAY_PATTERN.sub(replace_display, markdown)
    markdown = import_tags.MATH_PATTERN.sub(replace_inline, markdown)

    return markdown, math_placeholders


def extract_equations_to_placeholders(markdown: str) -> Tuple[str, Dict[str, str]]:
    """
    Finds all inline and display math expressions, replaces them with placeholders,
    and returns the modified string and a map from placeholder to the original equation.
    """
    equation_map = {}

    def replacer(match):
        uid = get_unique_id()
        placeholder = f"{EQUATION_PLACEHOLDER_PREFIX}{uid}{PLACEHOLDER_SUFFIX}"
        equation_map[placeholder] = match.group(0)
        return placeholder

    # Important: Replace display math first to avoid its content being partially matched by inline math.
    markdown = import_tags.MATH_DISPLAY_PATTERN.sub(replacer, markdown)
    markdown = import_tags.MATH_PATTERN.sub(replacer, markdown)

    return markdown, equation_map


def substitute_equation_placeholders(
    text: str, placeholder_map: Dict[str, LumiContent]
) -> str:
    """
    Substitutes equation placeholders in a string with their original content.

    Args:
        text: The string containing equation placeholders.
        placeholder_map: A dictionary mapping placeholders to their content.

    Returns:
        The string with placeholders replaced.
    """
    equation_placeholder_pattern = re.compile(
        f"({re.escape(EQUATION_PLACEHOLDER_PREFIX)}.*?{re.escape(PLACEHOLDER_SUFFIX)})"
    )

    def replace_equation(match):
        placeholder = match.group(1)
        return placeholder_map.get(placeholder, "")

    return equation_placeholder_pattern.sub(replace_equation, text)


def markdown_to_html(markdown: str) -> str:
    """
    Converts markdown text to an html string, protecting LaTeX math expressions.

    Args:
        markdown (str): The markdown to convert.

    Returns:
        str: The converted html string.
    """
    if not markdown:
        return ""

    markdown = _apply_katex_substitutions(markdown)
    markdown = markdown.replace("\\$", "\\\\$")
    protected_markdown, math_placeholders = _protect_math_expressions(markdown)
    with HtmlRenderer() as renderer:
        doc = Document(protected_markdown)
        html = renderer.render(doc)

    # Restore the original math expressions
    for placeholder, original_math in math_placeholders.items():
        html = html.replace(placeholder, original_math)

    return html


def postprocess_content_text(text: str, strip_double_brackets=False) -> str:
    """
    Post-processes text right before it is finalized in a LumiSpan

    Args:
        text (str): The text to clean.

    Returns:
        str: The cleaned text.
    """
    # (1) Swaps $ in for escaped \\$
    text = text.replace("\\$", "$")
    # (2) Removing any remaining Lumi tags that were not correctly processed.
    text = re.sub(r"\[\[l-.*?\]\]", "", text)
    # (3) If the flag is set, remove remaining double square brackets, e.g. [[content]]
    if strip_double_brackets:
        text = re.sub(r"\[\[.*?\]\]", "", text)
    return text
